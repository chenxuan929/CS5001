{\rtf1\ansi\ansicpg936\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Written #1
\f1\b0 \
1A\
def print_formatted():\
    print(Str)\
Str = "I want to eat hotpot"\
print_formatted()\
\
1B\
def get_max():\
    result = max([2,4])\
    return int(result)\
print(get_max())\
 \
1C     \
def log_base_two():\
    import math\
    return float(math.log2(2))\
print(log_base_two())\
\
\
\

\f0\b Written #2\

\f1\b0 Because the code will return at line2 and anything after \'93 return \'93 will not be executed. When we start the function, it will execute line 1, line 2, then line 6, but skip the line 3. If we want to execute line 3, we have to put it before line 2. \
\
\

\f0\b Written #3\

\f1\b0 3A\
19\
19\
\
3B\
19\
18\
19\
18\
19\
\

\f0\b Written #4\

\f1\b0 Function 1. After printing a value, we can no longer use it. But when a function returns a value, we can store It to a variable and do whatever with it.\
\

\f0\b Written #5\

\f1\b0 5A
\f0\b \

\f1\b0 def divide( x: int, y: int) -> int:\
	return x / y\
	x = x + 5\
\
5B\
Type annotation allows developer communicate expected argument types and return values with the interpreter effectively. Can decrease the amount of work and also keep dynamic typing\'92s advantage.\
\
}